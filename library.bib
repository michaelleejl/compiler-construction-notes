@article{kelsey-1995,
	author = {Kelsey, Richard A.},
	journal = {SIGPLAN notices},
	month = {3},
	number = {3},
	pages = {13--22},
	title = {{A correspondence between continuation passing style and static single assignment form}},
	volume = {30},
	year = {1995},
	doi = {10.1145/202530.202532},
	url = {https://doi.org/10.1145/202530.202532},
}

@article{yallop-2023,
	author = {Yallop, Jeremy and Xie, Ningning and Krishnaswami, Neel},
	journal = {Proceedings of the ACM on programming languages},
	month = {6},
	number = {PLDI},
	pages = {1194--1217},
	title = {{flap: A Deterministic Parser with Fused Lexing}},
	volume = {7},
	year = {2023},
	doi = {10.1145/3591269},
	url = {https://doi.org/10.1145/3591269},
}

@book{mccarthy-1963,
	author = {McCarthy, John},
	booktitle = {Studies in logic and the foundations of mathematics},
	month = {1},
	pages = {33--70},
	title = {{A basis for a mathematical theory of computation)}},
	year = {1963},
	doi = {10.1016/s0049-237x(08)72018-4},
	url = {https://doi.org/10.1016/s0049-237x(08)72018-4},
}

@article{griffin-1990,
	author = {Griffin, Timothy G.},
	journal = {POPL '90: Proceedings of the 17th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
	month = {1},
	title = {{A formulae-as-type notion of control}},
	year = {1990},
	doi = {10.1145/96709.96714},
	url = {https://doi.org/10.1145/96709.96714},
}

@misc{drup-2018,
	author = {Drup},
	month = {5},
	title = {{An OCaml quine}},
	year = {2018},
	url = {https://drup.github.io/2018/05/30/quine/},
}

@book{nielsen-1993,
	author = {Nielsen, Jakob},
	month = {1},
	title = {{Usability Engineering}},
	year = {1993},
	url = {https://dl.acm.org/citation.cfm?id=2821575},
}

@article{owens-2009,
	author = {Owens, Scott and Reppy, John and Turon, Aaron},
	journal = {Journal of functional programming},
	month = {3},
	number = {2},
	pages = {173--190},
	title = {{Regular-expression derivatives re-examined}},
	volume = {19},
	year = {2009},
	doi = {10.1017/s0956796808007090},
	url = {https://doi.org/10.1017/s0956796808007090},
}

@book{sebesta-1993,
	author = {Sebesta, Robert W.},
	month = {3},
	title = {{Concepts of programming languages (2nd ed.)}},
	year = {1993},
	url = {https://dl.acm.org/citation.cfm?id=230189},
}

@article{mytkowicz-2014,
	author = {Mytkowicz, Todd and Musuvathi, Madanlal and Schulte, Wolfram},
	journal = {ASPLOS '14: Proceedings of the 19th international conference on Architectural support for programming languages and operating systems},
	month = {2},
	title = {{Data-parallel finite-state machines}},
	year = {2014},
	doi = {10.1145/2541940.2541988},
	url = {https://doi.org/10.1145/2541940.2541988},
}

@article{owens-2009,
	author = {Owens, Scott and Reppy, John and Turon, Aaron},
	journal = {Journal of functional programming},
	month = {3},
	number = {2},
	pages = {173--190},
	title = {{Regular-expression derivatives re-examined}},
	volume = {19},
	year = {2009},
	doi = {10.1017/s0956796808007090},
	url = {https://doi.org/10.1017/s0956796808007090},
}

@book{kernighan-1978,
	author = {Kernighan, Brian W. and Ritchie, Dennis M.},
	month = {1},
	title = {{The C programming language}},
	year = {1978},
	url = {https://usuaris.tinet.cat/bertolin/pdfs/c_programming_language.pdf},
}

@book{sipser-2006,
  added-at = {2014-03-03T20:31:33.000+0100},
  author = {Sipser, Michael},
  biburl = {https://www.bibsonomy.org/bibtex/2317441ce12cacafa82cd32c4b2ed95cc/ytyoun},
  edition = {Second},
  interhash = {6d6f89523b99e25120368e673ca59c01},
  intrahash = {317441ce12cacafa82cd32c4b2ed95cc},
  isbn = {7111173279 9787111173274},
  keywords = {automata complexity computation gadget hamiltonian np-hardness sipser textbook},
  publisher = {Course Technology},
  refid = {660595094},
  timestamp = {2016-12-04T08:23:10.000+0100},
  title = {Introduction to the Theory of Computation},
  year = 2006
}

@inproceedings{krishnaswami-2019,
author = {Krishnaswami, Neelakantan R. and Yallop, Jeremy},
title = {A typed, algebraic approach to parsing},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314625},
doi = {10.1145/3314221.3314625},
abstract = {In this paper, we recall the definition of the context-free expressions (or µ-regular expressions), an algebraic presentation of the context-free languages. Then, we define a core type system for the context-free expressions which gives a compositional criterion for identifying those context-free expressions which can be parsed unambiguously by predictive algorithms in the style of recursive descent or LL(1). Next, we show how these typed grammar expressions can be used to derive a parser combinator library which both guarantees linear-time parsing with no backtracking and single-token lookahead, and which respects the natural denotational semantics of context-free expressions. Finally, we show how to exploit the type information to write a staged version of this library, which produces dramatic increases in performance, even outperforming code generated by the standard parser generator tool ocamlyacc.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {379–393},
numpages = {15},
keywords = {Kleene algebra, context-free languages, parsing, type theory},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@inproceedings{sperber-1995,
author = {Sperber, Michael and Thiemann, Peter},
title = {The essence of LR parsing},
year = {1995},
isbn = {0897917200},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/215465.215579},
doi = {10.1145/215465.215579},
booktitle = {Proceedings of the 1995 ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
pages = {146–155},
numpages = {10},
location = {La Jolla, California, USA},
series = {PEPM '95}
}



@inbook{taha-2004,
	abstract = {Multi-stage programming (MSP) is a paradigm for developing generic software that does not pay a runtime penalty for this generality. This is achieved through concise, carefully-designed language extensions that support runtime code generation and program execution. Additionally, type systems for MSP languages are designed to statically ensure that dynamically generated programs are type-safe, and therefore require no type checking after they are generated.},
	address = {Berlin, Heidelberg},
	author = {Taha, Walid},
	booktitle = {Domain-Specific Program Generation: International Seminar, Dagstuhl Castle, Germany, March 23-28, 2003. Revised Papers},
	doi = {10.1007/978-3-540-25935-0_3},
	editor = {Lengauer, Christian and Batory, Don and Consel, Charles and Odersky, Martin},
	isbn = {978-3-540-25935-0},
	pages = {30--50},
	publisher = {Springer Berlin Heidelberg},
	title = {A Gentle Introduction to Multi-stage Programming},
	url = {https://doi.org/10.1007/978-3-540-25935-0_3},
	year = {2004},
	bdsk-url-1 = {https://doi.org/10.1007/978-3-540-25935-0_3}}

@article{robinson-1965,
author = {Robinson, J. A.},
title = {A Machine-Oriented Logic Based on the Resolution Principle},
year = {1965},
issue_date = {Jan. 1965},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {1},
issn = {0004-5411},
url = {https://doi.org/10.1145/321250.321253},
doi = {10.1145/321250.321253},
journal = {J. ACM},
month = {jan},
pages = {23–41},
numpages = {19}
}

@inproceedings{pottier-2014,
author = {Pottier, Fran\c{c}ois},
title = {Hindley-milner elaboration in applicative style: functional pearl},
year = {2014},
isbn = {9781450328739},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2628136.2628145},
doi = {10.1145/2628136.2628145},
abstract = {Type inference - the problem of determining whether a program is well-typed - is well-understood. In contrast, elaboration - the task of constructing an explicitly-typed representation of the program - seems to have received relatively little attention, even though, in a non-local type inference system, it is non-trivial. We show that the constraint-based presentation of Hindley-Milner type inference can be extended to deal with elaboration, while preserving its elegance. This involves introducing a new notion of "constraint with a value", which forms an applicative functor.},
booktitle = {Proceedings of the 19th ACM SIGPLAN International Conference on Functional Programming},
pages = {203–212},
numpages = {10},
keywords = {type inference, polymorphism, elaboration, constraints},
location = {Gothenburg, Sweden},
series = {ICFP '14}
}
